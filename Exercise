=begin
Bigger is Greater

Given a word , rearrange the letters of  to construct another word  in such a way that  is lexicographically greater than . In case of multiple possible answers, find the lexicographically smallest one among them.

*Input Format*
The first line of input contains , the number of test cases. Each of the next  lines contains .

*Constraints*
-> 1 <= t <= 10^5
-> 1 <= |w| <= 100
-> "w" will contain only lower-case English letters and its length will not exceed .

*Output Format*
For each testcase, output a string lexicographically bigger than  in a separate line. In case of multiple possible answers, print the lexicographically smallest one, and if no answer exists, print no answer.

*Sample Input*
5
ab
bb
hefg
dhck
dkhc
*Sample Output*
ba
no answer
hegf
dhkc
hcdk

*Explanation*
- Test case 1: 
There exists only one string greater than ab which can be built by rearranging ab. That is ba.
- Test case 2: 
Not possible to rearrange bb and get a lexicographically greater string.
- Test case 3: 
hegf is the next string lexicographically greater than hefg.
- Test case 4: 
dhkc is the next string lexicographically greater than dhck.
- Test case 5: 
hcdk is the next string lexicographically greater than dkhc.
=end

t = 5.to_i
w = ["ab", "bb", "hefg", "dhck", "dkhc"]
w_char = [["a", "b"], ["b","b"],["h","e","f","g"],["d","h","c","k"],["d","k","h","c"]]

new = []
for n in (0..t-1)
    new_i = []
    arr_len = w_char[n].count-1
    if w_char[n].uniq.count == 1
        puts "no answer"
    elsif (w_char[n][arr_len] > w_char[n][arr_len-1])
        a = w_char[n][arr_len]
        b = w_char[n][arr_len-1]
        w_char[n][arr_len-1] = a
        w_char[n][arr_len] = b
        print w_char[n]
        puts
    else
        w_char[n]
        cont = 0
        for i in 0..arr_len
            w_char[n][arr_len-i] < w_char[n][arr_len-i-1] ? cont +=1 : break
            puts cont
        end

        for i in 0..(arr_len-cont-2)
            novo_arr.push(w_char[x][i])
        end
        
            novo_arr[arr_len-cont-1] = a valor
        
        for i in (arr_len-cont)..arr_len
            no_arr[i]
        end
    end
end
